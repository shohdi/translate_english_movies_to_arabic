#!/usr/bin/env python
"""Build a preview EPUB from a live translation progress text file."""

from __future__ import annotations

import argparse
import base64
from pathlib import Path

from bs4 import BeautifulSoup
from ebooklib import ITEM_DOCUMENT, epub


def parse_progress(progress_path: Path) -> dict[str, str]:
    result: dict[str, str] = {}
    with progress_path.open("r", encoding="utf-8") as file:
        for line in file:
            line = line.rstrip("\n")
            if not line or "\t" not in line:
                continue
            key, encoded = line.split("\t", 1)
            try:
                decoded = base64.b64decode(encoded.encode("ascii")).decode("utf-8")
            except Exception:
                continue
            result[key] = decoded
    return result


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description=(
            "Create an EPUB preview from an original EPUB plus a translation progress "
            "text file. The progress file is read-only and never modified."
        )
    )
    parser.add_argument("--epub-path", required=True, help="Path to the original EPUB.")
    parser.add_argument(
        "--progress-path",
        required=True,
        help="Path to progress text file generated by epub_book_translator.py.",
    )
    parser.add_argument(
        "--output-path",
        help="Preview EPUB output path (default: <book>.progress_preview.epub).",
    )
    parser.add_argument(
        "--mark-pending",
        action="store_true",
        help="Prefix untranslated paragraphs with [PENDING] for visibility.",
    )
    return parser.parse_args()


def ensure_book_uids(book: epub.EpubBook) -> None:
    counter = 0
    for item in book.get_items():
        uid = getattr(item, "uid", None)
        if uid:
            continue
        file_name = getattr(item, "file_name", None) or f"item_{counter}"
        safe_name = str(file_name).replace("/", "_").replace("\\", "_")
        setattr(item, "uid", f"auto_uid_{safe_name}_{counter}")
        counter += 1

    def _fix_toc_node(node, idx_seed: int = 0):
        if isinstance(node, (list, tuple)):
            for i, child in enumerate(node):
                _fix_toc_node(child, idx_seed + i + 1)
            return
        uid = getattr(node, "uid", None)
        if uid:
            return
        title = getattr(node, "title", None) or getattr(node, "href", None) or "toc"
        safe_title = str(title).replace("/", "_").replace("\\", "_").replace(" ", "_")
        try:
            setattr(node, "uid", f"auto_toc_{safe_title}_{idx_seed}")
        except Exception:
            return

    _fix_toc_node(book.toc)


def main() -> None:
    args = parse_args()
    epub_path = Path(args.epub_path).expanduser().resolve()
    progress_path = Path(args.progress_path).expanduser().resolve()

    if not epub_path.exists():
        raise FileNotFoundError(f"EPUB file does not exist: {epub_path}")
    if not progress_path.exists():
        raise FileNotFoundError(f"Progress file does not exist: {progress_path}")

    output_path = (
        Path(args.output_path).expanduser().resolve()
        if args.output_path
        else epub_path.with_name(f"{epub_path.stem}.progress_preview.epub")
    )

    print(f"[1/3] Reading progress file (read-only): {progress_path}")
    progress = parse_progress(progress_path)
    print(f"Loaded {len(progress)} translated paragraph entries.")

    print(f"[2/3] Applying progress to EPUB: {epub_path}")
    book = epub.read_epub(str(epub_path))
    total = 0
    applied = 0
    doc_index = 0

    for item in book.get_items_of_type(ITEM_DOCUMENT):
        doc_index += 1
        soup = BeautifulSoup(item.get_content(), "xml")
        paragraph_index = 0

        for paragraph in soup.find_all("p"):
            original_text = paragraph.get_text(" ", strip=True)
            if not original_text:
                continue

            paragraph_index += 1
            total += 1
            key = f"{item.file_name}::d{doc_index}_p{paragraph_index}"

            if key in progress:
                paragraph.clear()
                paragraph.append(progress[key])
                applied += 1
            elif args.mark_pending:
                paragraph.clear()
                paragraph.append(f"[PENDING] {original_text}")

        item.set_content(str(soup).encode("utf-8"))

    print(f"[3/3] Writing preview EPUB: {output_path}")
    ensure_book_uids(book)
    epub.write_epub(str(output_path), book)
    print(f"Done. Applied translations: {applied}/{total} paragraphs")
    print("Note: progress file was not modified.")


if __name__ == "__main__":
    main()
